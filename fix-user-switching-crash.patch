From 458df184f16a3f45db6cc7fb7ed68fc0b7de4715 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Fri, 20 Jun 2014 17:10:37 -0400
Subject: [PATCH 1/2] user-manager: frob right state machine

We're setting the seat state as loaded when a session gets loaded.
---
 gui/simple-greeter/gdm-user-manager.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/gui/simple-greeter/gdm-user-manager.c b/gui/simple-greeter/gdm-user-manager.c
index a2eb914..80120ec 100644
--- a/gui/simple-greeter/gdm-user-manager.c
+++ b/gui/simple-greeter/gdm-user-manager.c
@@ -1060,61 +1060,61 @@ maybe_add_new_session (GdmUserManagerNewSession *new_session)
                 g_debug ("GdmUserManager: excluding user '%s'", pwent->pw_name);
                 goto failed;
         }
 
         user = g_hash_table_lookup (manager->priv->users_by_name, pwent->pw_name);
         if (user == NULL) {
                 g_debug ("Creating new user");
 
                 user = g_object_new (GDM_TYPE_USER, NULL);
 
                 _gdm_user_update_from_pwent (user, pwent);
                 is_new = TRUE;
         } else {
                 is_new = FALSE;
         }
 
         add_session_for_user (manager, user, new_session->id);
 
         /* if we haven't yet gotten the login frequency
            then at least add one because the session exists */
         if (gdm_user_get_login_frequency (user) == 0) {
                 _gdm_user_update_login_frequency (user, 1);
         }
 
         /* only add the user if it was newly created */
         if (is_new) {
                 add_user (manager, user);
                 g_object_unref (user);
         }
 
-        manager->priv->seat.state = GDM_USER_MANAGER_SEAT_STATE_LOADED;
+        new_session->state = GDM_USER_MANAGER_NEW_SESSION_STATE_LOADED;
         unload_new_session (new_session);
         return;
 
 failed:
         unload_new_session (new_session);
 }
 
 static void
 load_new_session_incrementally (GdmUserManagerNewSession *new_session)
 {
         switch (new_session->state) {
         case GDM_USER_MANAGER_NEW_SESSION_STATE_GET_PROXY:
                 get_proxy_for_new_session (new_session);
                 break;
         case GDM_USER_MANAGER_NEW_SESSION_STATE_GET_UID:
                 get_uid_for_new_session (new_session);
                 break;
         case GDM_USER_MANAGER_NEW_SESSION_STATE_GET_X11_DISPLAY:
                 get_x11_display_for_new_session (new_session);
                 break;
         case GDM_USER_MANAGER_NEW_SESSION_STATE_MAYBE_ADD:
                 maybe_add_new_session (new_session);
                 break;
         case GDM_USER_MANAGER_NEW_SESSION_STATE_LOADED:
                 break;
         default:
                 g_assert_not_reached ();
         }
 }
 
-- 
2.1.0


From 5e1d6da52e357ffd72ad017c0355cade1beaab55 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Wed, 10 Sep 2014 10:25:01 -0400
Subject: [PATCH 2/2] user-manager: don't let multiple close together queues
 clobber state machine

---
 gui/simple-greeter/gdm-user-manager.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/gui/simple-greeter/gdm-user-manager.c b/gui/simple-greeter/gdm-user-manager.c
index 80120ec..73dd9f0 100644
--- a/gui/simple-greeter/gdm-user-manager.c
+++ b/gui/simple-greeter/gdm-user-manager.c
@@ -124,60 +124,61 @@ typedef struct
         char                            *x11_display;
 } GdmUserManagerNewSession;
 
 struct GdmUserManagerPrivate
 {
         GHashTable            *users_by_name;
         GHashTable            *sessions;
         GHashTable            *shells;
         DBusGConnection       *connection;
         DBusGProxyCall        *get_sessions_call;
 
         GdmUserManagerSeat     seat;
 
         GSList                *new_sessions;
 
         GFileMonitor          *passwd_monitor;
         GFileMonitor          *shells_monitor;
 
         GSList                *exclude_usernames;
         GSList                *include_usernames;
         gboolean               include_all;
 
         gboolean               load_passwd_pending;
 
         guint                  load_id;
         guint                  reload_passwd_id;
         guint                  ck_history_id;
         guint                  ck_history_watchdog_id;
         GPid                   ck_history_pid;
 
+        gboolean               load_initiated;
         gboolean               is_loaded;
         gboolean               has_multiple_users;
 };
 
 enum {
         PROP_0,
         PROP_INCLUDE_ALL,
         PROP_INCLUDE_USERNAMES_LIST,
         PROP_EXCLUDE_USERNAMES_LIST,
         PROP_IS_LOADED,
         PROP_HAS_MULTIPLE_USERS
 };
 
 enum {
         USER_ADDED,
         USER_REMOVED,
         USER_IS_LOGGED_IN_CHANGED,
         USER_CHANGED,
         LAST_SIGNAL
 };
 
 static guint signals [LAST_SIGNAL] = { 0, };
 
 static void     gdm_user_manager_class_init (GdmUserManagerClass *klass);
 static void     gdm_user_manager_init       (GdmUserManager      *user_manager);
 static void     gdm_user_manager_finalize   (GObject             *object);
 
 static void     load_seat_incrementally     (GdmUserManager *manager);
 static void     unload_seat                 (GdmUserManager *manager);
 static void     load_users                  (GdmUserManager *manager);
@@ -2403,62 +2404,63 @@ gdm_user_manager_class_init (GdmUserManagerClass *klass)
                               G_SIGNAL_RUN_LAST,
                               G_STRUCT_OFFSET (GdmUserManagerClass, user_removed),
                               NULL, NULL,
                               g_cclosure_marshal_VOID__OBJECT,
                               G_TYPE_NONE, 1, GDM_TYPE_USER);
         signals [USER_IS_LOGGED_IN_CHANGED] =
                 g_signal_new ("user-is-logged-in-changed",
                               G_TYPE_FROM_CLASS (klass),
                               G_SIGNAL_RUN_LAST,
                               G_STRUCT_OFFSET (GdmUserManagerClass, user_is_logged_in_changed),
                               NULL, NULL,
                               g_cclosure_marshal_VOID__OBJECT,
                               G_TYPE_NONE, 1, GDM_TYPE_USER);
         signals [USER_CHANGED] =
                 g_signal_new ("user-changed",
                               G_TYPE_FROM_CLASS (klass),
                               G_SIGNAL_RUN_LAST,
                               G_STRUCT_OFFSET (GdmUserManagerClass, user_changed),
                               NULL, NULL,
                               g_cclosure_marshal_VOID__OBJECT,
                               G_TYPE_NONE, 1, GDM_TYPE_USER);
 
         g_type_class_add_private (klass, sizeof (GdmUserManagerPrivate));
 }
 
 void
 gdm_user_manager_queue_load (GdmUserManager *manager)
 {
         g_return_if_fail (GDM_IS_USER_MANAGER (manager));
 
-        if (! manager->priv->is_loaded) {
+        if (! manager->priv->load_initiated) {
                 queue_load_seat_and_users (manager);
+                manager->priv->load_initiated = TRUE;
         }
 }
 
 static void
 gdm_user_manager_init (GdmUserManager *manager)
 {
         GError        *error;
 
         manager->priv = GDM_USER_MANAGER_GET_PRIVATE (manager);
 
         /* sessions */
         manager->priv->sessions = g_hash_table_new_full (g_str_hash,
                                                          g_str_equal,
                                                          g_free,
                                                          g_free);
 
         /* users */
         manager->priv->users_by_name = g_hash_table_new_full (g_str_hash,
                                                               g_str_equal,
                                                               g_free,
                                                               g_object_unref);
 
         if (manager->priv->include_all == TRUE) {
                 monitor_local_users (manager);
         }
 
         g_assert (manager->priv->seat.proxy == NULL);
 
         error = NULL;
         manager->priv->connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
-- 
2.1.0

