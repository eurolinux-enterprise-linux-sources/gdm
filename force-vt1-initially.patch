From 0113644f7c6c8ac1521c313b4eae6781119fa40f Mon Sep 17 00:00:00 2001
From: Lennart Poettering <lennart@poettering.net>
Date: Mon, 6 Aug 2012 21:41:16 +0200
Subject: [PATCH] gdm: always run gdm on VT1

This drops automatic VT allocation schemes for the initial display in
favour of a compile time hardcoded VT assignment. The automatic
allocation schemes are inherently racy since a simpler output to the
console might already influence it and result in gdm running on another
than the intended VT.

This patch adds a --with-initial-vt= switch to configure which may be
used to set the VT gdm will run the initial server on. It defaults to 1.

https://fedoraproject.org/wiki/Features/DisplayManagerRework

Backported by Ray Strode

https://bugzilla.gnome.org/show_bug.cgi?id=511168
---
 configure.ac                       |  2 +
 daemon/gdm-display.c               | 65 ++++++++++++++-----------
 daemon/gdm-display.h               |  3 ++
 daemon/gdm-display.xml             |  3 ++
 daemon/gdm-factory-slave.c         |  2 +-
 daemon/gdm-local-display-factory.c | 16 +++++--
 daemon/gdm-product-slave.c         |  2 +-
 daemon/gdm-server.c                | 98 +++++++++++++-------------------------
 daemon/gdm-server.h                |  4 +-
 daemon/gdm-simple-slave.c          | 19 +++-----
 daemon/gdm-simple-slave.h          |  3 +-
 daemon/gdm-slave.c                 | 47 ++++++++++++------
 daemon/gdm-static-display.c        | 17 -------
 daemon/simple-slave-main.c         |  4 +-
 14 files changed, 135 insertions(+), 150 deletions(-)

diff --git a/configure.ac b/configure.ac
index 490f709..33fdd26 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1407,60 +1407,62 @@ if test "$enable_debug" = "yes"; then
 else
 	if test "x$enable_debug" = "xno"; then
 		DEBUG_CFLAGS="-DG_DISABLE_ASSERT -DG_DISABLE_CHECKS"
   	else
     		DEBUG_CFLAGS=""
   	fi
 fi
 AC_SUBST(DEBUG_CFLAGS)
 
 #
 # Enable Profiling
 #
 AC_ARG_ENABLE(profiling,
               AS_HELP_STRING([--enable-profiling],
                              [turn on profiling]),,
               enable_profiling=yes)
 
 if test "$enable_profiling" = "yes"; then
     AC_DEFINE(ENABLE_PROFILING,1,[enable profiling])
 fi
 
 #
 # Set SHELL to use in scripts.
 #
 if test x$os_solaris = xyes ; then
    XSESSION_SHELL=/bin/ksh
 else
    XSESSION_SHELL=/bin/sh
 fi
 
+AC_DEFINE_UNQUOTED(GDM_INITIAL_VT, "1", [Initial Virtual Terminal])
+
 # Set configuration choices.
 #
 AC_SUBST(XSESSION_SHELL)
 AC_DEFINE_UNQUOTED(XSESSION_SHELL,"$XSESSION_SHELL",[xsession shell])
 AC_SUBST(SOUND_PROGRAM)
 AC_DEFINE_UNQUOTED(SOUND_PROGRAM,"$SOUND_PROGRAM",[])
 
 AC_SUBST(X_PATH)
 AC_SUBST(X_SERVER)
 AC_SUBST(X_SERVER_PATH)
 AC_SUBST(X_CONFIG_OPTIONS)
 AC_DEFINE_UNQUOTED(X_SERVER,"$X_SERVER",[])
 AC_DEFINE_UNQUOTED(X_SERVER_PATH,"$X_SERVER_PATH",[])
 AC_DEFINE_UNQUOTED(X_CONFIG_OPTIONS,"$X_CONFIG_OPTIONS", [Options used when launching xserver])
 
 AC_SUBST(X_XNEST_CMD)
 AC_SUBST(X_XNEST_CONFIG_OPTIONS)
 AC_SUBST(X_XNEST_UNSCALED_FONTPATH)
 AC_DEFINE_UNQUOTED(X_XNEST_CMD,"$X_XNEST_CMD",[])
 AC_DEFINE_UNQUOTED(X_XNEST_CONFIG_OPTIONS,"$X_XNEST_CONFIG_OPTIONS",[])
 AC_DEFINE_UNQUOTED(X_XNEST_UNSCALED_FONTPATH,"$X_XNEST_UNSCALED_FONTPATH",[])
 
 ## Stuff for debian/changelog.in
 #if test -e "debian/changelog"; then
 #  DEBIAN_DATESTAMP=`head -1 debian/changelog| sed -e 's/.*cvs.//' -e 's/).*//'`
 #  DEBIAN_DATE=`grep '^ --' debian/changelog | head -1 | sed -e 's/.*  //'`
 #else
 #  DEBIAN_DATESTAMP=`date +%Y%m%d%H%M%s`
 #  DEBIAN_DATE=`date -R`
 #fi
diff --git a/daemon/gdm-display.c b/daemon/gdm-display.c
index 77877b4..0eacbce 100644
--- a/daemon/gdm-display.c
+++ b/daemon/gdm-display.c
@@ -39,82 +39,81 @@
 
 #include "gdm-settings-direct.h"
 #include "gdm-settings-keys.h"
 
 #include "gdm-slave-proxy.h"
 
 static guint32 display_serial = 1;
 
 #define GDM_DISPLAY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GDM_TYPE_DISPLAY, GdmDisplayPrivate))
 
 #define DEFAULT_SLAVE_COMMAND LIBEXECDIR "/gdm-simple-slave"
 
 struct GdmDisplayPrivate
 {
         char                 *id;
         char                 *seat_id;
 
         char                 *remote_hostname;
         int                   x11_display_number;
         char                 *x11_display_name;
         int                   status;
         time_t                creation_time;
         GTimer               *slave_timer;
         char                 *slave_command;
 
         char                 *x11_cookie;
         gsize                 x11_cookie_size;
         GdmDisplayAccessFile *access_file;
 
         guint                 is_local : 1;
-        guint                 force_active_vt : 1;
-
+        guint                 is_initial : 1;
         guint                 finish_idle_id;
 
         GdmSlaveProxy        *slave_proxy;
         DBusGConnection      *connection;
         GdmDisplayAccessFile *user_access_file;
 };
 
 enum {
         PROP_0,
         PROP_ID,
         PROP_STATUS,
         PROP_SEAT_ID,
         PROP_REMOTE_HOSTNAME,
         PROP_X11_DISPLAY_NUMBER,
         PROP_X11_DISPLAY_NAME,
         PROP_X11_COOKIE,
         PROP_X11_AUTHORITY_FILE,
         PROP_IS_LOCAL,
-        PROP_FORCE_ACTIVE_VT,
         PROP_SLAVE_COMMAND,
+        PROP_IS_INITIAL
 };
 
 static void     gdm_display_class_init  (GdmDisplayClass *klass);
 static void     gdm_display_init        (GdmDisplay      *display);
 static void     gdm_display_finalize    (GObject         *object);
 
 G_DEFINE_ABSTRACT_TYPE (GdmDisplay, gdm_display, G_TYPE_OBJECT)
 
 GQuark
 gdm_display_error_quark (void)
 {
         static GQuark ret = 0;
         if (ret == 0) {
                 ret = g_quark_from_static_string ("gdm_display_error");
         }
 
         return ret;
 }
 
 static guint32
 get_next_display_serial (void)
 {
         guint32 serial;
 
         serial = display_serial++;
 
         if ((gint32)display_serial < 0) {
                 display_serial = 1;
         }
 
@@ -465,60 +464,74 @@ gdm_display_get_remote_hostname (GdmDisplay *display,
 }
 
 gboolean
 gdm_display_get_x11_display_number (GdmDisplay *display,
                                     int        *number,
                                     GError    **error)
 {
        g_return_val_if_fail (GDM_IS_DISPLAY (display), FALSE);
 
        if (number != NULL) {
                *number = display->priv->x11_display_number;
        }
 
        return TRUE;
 }
 
 gboolean
 gdm_display_get_seat_id (GdmDisplay *display,
                          char      **seat_id,
                          GError    **error)
 {
        g_return_val_if_fail (GDM_IS_DISPLAY (display), FALSE);
 
        if (seat_id != NULL) {
                *seat_id = g_strdup (display->priv->seat_id);
        }
 
        return TRUE;
 }
 
+gboolean
+gdm_display_is_initial (GdmDisplay  *display,
+                        gboolean    *is_initial,
+                        GError     **error)
+{
+        g_return_val_if_fail (GDM_IS_DISPLAY (display), FALSE);
+
+        if (is_initial != NULL) {
+                *is_initial = display->priv->is_initial;
+        }
+
+        return TRUE;
+}
+
 static gboolean
 finish_idle (GdmDisplay *display)
 {
         display->priv->finish_idle_id = 0;
         /* finish may end up finalizing object */
         gdm_display_finish (display);
         return FALSE;
 }
 
 static void
 queue_finish (GdmDisplay *display)
 {
         if (display->priv->finish_idle_id == 0) {
                 display->priv->finish_idle_id = g_idle_add ((GSourceFunc)finish_idle, display);
         }
 }
 
 static void
 slave_exited (GdmSlaveProxy       *proxy,
               int                  code,
               GdmDisplay          *display)
 {
         g_debug ("GdmDisplay: Slave exited: %d", code);
 
         queue_finish (display);
 }
 
 static void
 slave_died (GdmSlaveProxy       *proxy,
             int                  signum,
@@ -550,64 +563,63 @@ gdm_display_real_prepare (GdmDisplay *display)
         g_return_val_if_fail (GDM_IS_DISPLAY (display), FALSE);
 
         g_debug ("GdmDisplay: prepare display");
 
         g_assert (display->priv->slave_proxy == NULL);
 
         if (!gdm_display_create_authority (display)) {
                 g_warning ("Unable to set up access control for display %d",
                            display->priv->x11_display_number);
                 return FALSE;
         }
 
         _gdm_display_set_status (display, GDM_DISPLAY_PREPARED);
 
         display->priv->slave_proxy = gdm_slave_proxy_new ();
         g_signal_connect (display->priv->slave_proxy,
                           "exited",
                           G_CALLBACK (slave_exited),
                           display);
         g_signal_connect (display->priv->slave_proxy,
                           "died",
                           G_CALLBACK (slave_died),
                           display);
 
         log_file = g_strdup_printf ("%s-slave.log", display->priv->x11_display_name);
         log_path = g_build_filename (LOGDIR, log_file, NULL);
         g_free (log_file);
         gdm_slave_proxy_set_log_path (display->priv->slave_proxy, log_path);
         g_free (log_path);
 
-        command = g_strdup_printf ("%s --display-id %s %s",
+        command = g_strdup_printf ("%s --display-id %s",
                                    display->priv->slave_command,
-                                   display->priv->id,
-                                   display->priv->force_active_vt? "--force-active-vt" : "");
+                                   display->priv->id);
         gdm_slave_proxy_set_command (display->priv->slave_proxy, command);
         g_free (command);
 
         return TRUE;
 }
 
 gboolean
 gdm_display_prepare (GdmDisplay *display)
 {
         gboolean ret;
 
         g_return_val_if_fail (GDM_IS_DISPLAY (display), FALSE);
 
         g_debug ("GdmDisplay: Preparing display: %s", display->priv->id);
 
         g_object_ref (display);
         ret = GDM_DISPLAY_GET_CLASS (display)->prepare (display);
         g_object_unref (display);
 
         return ret;
 }
 
 
 static gboolean
 gdm_display_real_manage (GdmDisplay *display)
 {
         gboolean res;
 
         g_return_val_if_fail (GDM_IS_DISPLAY (display), FALSE);
 
@@ -801,166 +813,166 @@ static void
 _gdm_display_set_x11_display_number (GdmDisplay     *display,
                                      int             num)
 {
         display->priv->x11_display_number = num;
 }
 
 static void
 _gdm_display_set_x11_display_name (GdmDisplay     *display,
                                    const char     *x11_display)
 {
         g_free (display->priv->x11_display_name);
         display->priv->x11_display_name = g_strdup (x11_display);
 }
 
 static void
 _gdm_display_set_x11_cookie (GdmDisplay     *display,
                              const char     *x11_cookie)
 {
         g_free (display->priv->x11_cookie);
         display->priv->x11_cookie = g_strdup (x11_cookie);
 }
 
 static void
 _gdm_display_set_is_local (GdmDisplay     *display,
                            gboolean        is_local)
 {
         display->priv->is_local = is_local;
 }
 
 static void
-_gdm_display_set_force_active_vt (GdmDisplay     *display,
-                                  gboolean        force_active_vt)
-{
-        display->priv->force_active_vt = force_active_vt;
-}
-
-static void
 _gdm_display_set_slave_command (GdmDisplay     *display,
                                 const char     *command)
 {
         g_free (display->priv->slave_command);
         display->priv->slave_command = g_strdup (command);
 }
 
 static void
+_gdm_display_set_is_initial (GdmDisplay     *display,
+                             gboolean        initial)
+{
+        display->priv->is_initial = initial;
+}
+
+static void
 gdm_display_set_property (GObject        *object,
                           guint           prop_id,
                           const GValue   *value,
                           GParamSpec     *pspec)
 {
         GdmDisplay *self;
 
         self = GDM_DISPLAY (object);
 
         switch (prop_id) {
         case PROP_ID:
                 _gdm_display_set_id (self, g_value_get_string (value));
                 break;
         case PROP_STATUS:
                 _gdm_display_set_status (self, g_value_get_int (value));
                 break;
         case PROP_SEAT_ID:
                 _gdm_display_set_seat_id (self, g_value_get_string (value));
                 break;
         case PROP_REMOTE_HOSTNAME:
                 _gdm_display_set_remote_hostname (self, g_value_get_string (value));
                 break;
         case PROP_X11_DISPLAY_NUMBER:
                 _gdm_display_set_x11_display_number (self, g_value_get_int (value));
                 break;
         case PROP_X11_DISPLAY_NAME:
                 _gdm_display_set_x11_display_name (self, g_value_get_string (value));
                 break;
         case PROP_X11_COOKIE:
                 _gdm_display_set_x11_cookie (self, g_value_get_string (value));
                 break;
         case PROP_IS_LOCAL:
                 _gdm_display_set_is_local (self, g_value_get_boolean (value));
                 break;
-        case PROP_FORCE_ACTIVE_VT:
-                _gdm_display_set_force_active_vt (self, g_value_get_boolean (value));
-                break;
         case PROP_SLAVE_COMMAND:
                 _gdm_display_set_slave_command (self, g_value_get_string (value));
                 break;
+        case PROP_IS_INITIAL:
+                _gdm_display_set_is_initial (self, g_value_get_boolean (value));
+                break;
         default:
                 G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
                 break;
         }
 }
 
 static void
 gdm_display_get_property (GObject        *object,
                           guint           prop_id,
                           GValue         *value,
                           GParamSpec     *pspec)
 {
         GdmDisplay *self;
 
         self = GDM_DISPLAY (object);
 
         switch (prop_id) {
         case PROP_ID:
                 g_value_set_string (value, self->priv->id);
                 break;
         case PROP_STATUS:
                 g_value_set_int (value, self->priv->status);
                 break;
         case PROP_SEAT_ID:
                 g_value_set_string (value, self->priv->seat_id);
                 break;
         case PROP_REMOTE_HOSTNAME:
                 g_value_set_string (value, self->priv->remote_hostname);
                 break;
         case PROP_X11_DISPLAY_NUMBER:
                 g_value_set_int (value, self->priv->x11_display_number);
                 break;
         case PROP_X11_DISPLAY_NAME:
                 g_value_set_string (value, self->priv->x11_display_name);
                 break;
         case PROP_X11_COOKIE:
                 g_value_set_string (value, self->priv->x11_cookie);
                 break;
         case PROP_X11_AUTHORITY_FILE:
                 g_value_take_string (value,
                                      gdm_display_access_file_get_path (self->priv->access_file));
                 break;
         case PROP_IS_LOCAL:
                 g_value_set_boolean (value, self->priv->is_local);
                 break;
-        case PROP_FORCE_ACTIVE_VT:
-                g_value_set_boolean (value, self->priv->force_active_vt);
-                break;
         case PROP_SLAVE_COMMAND:
                 g_value_set_string (value, self->priv->slave_command);
                 break;
+        case PROP_IS_INITIAL:
+                g_value_set_boolean (value, self->priv->is_initial);
+                break;
         default:
                 G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
                 break;
         }
 }
 
 static gboolean
 register_display (GdmDisplay *display)
 {
         GError *error = NULL;
 
         error = NULL;
         display->priv->connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
         if (display->priv->connection == NULL) {
                 if (error != NULL) {
                         g_critical ("error getting system bus: %s", error->message);
                         g_error_free (error);
                 }
                 exit (1);
         }
 
         dbus_g_connection_register_g_object (display->priv->connection, display->priv->id, G_OBJECT (display));
 
         return TRUE;
 }
 
 /*
   dbus-send --system --print-reply --dest=org.gnome.DisplayManager /org/gnome/DisplayManager/Display1 org.freedesktop.DBus.Introspectable.Introspect
 */
 
@@ -1074,68 +1086,67 @@ gdm_display_class_init (GdmDisplayClass *klass)
                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
         g_object_class_install_property (object_class,
                                          PROP_SEAT_ID,
                                          g_param_spec_string ("seat-id",
                                                               "seat id",
                                                               "seat id",
                                                               NULL,
                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
         g_object_class_install_property (object_class,
                                          PROP_X11_COOKIE,
                                          g_param_spec_string ("x11-cookie",
                                                               "cookie",
                                                               "cookie",
                                                               NULL,
                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
         g_object_class_install_property (object_class,
                                          PROP_X11_AUTHORITY_FILE,
                                          g_param_spec_string ("x11-authority-file",
                                                               "authority file",
                                                               "authority file",
                                                               NULL,
                                                               G_PARAM_READABLE));
 
         g_object_class_install_property (object_class,
                                          PROP_IS_LOCAL,
                                          g_param_spec_boolean ("is-local",
                                                                NULL,
                                                                NULL,
                                                                TRUE,
                                                                G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-        g_object_class_install_property (object_class,
-                                         PROP_FORCE_ACTIVE_VT,
-                                         g_param_spec_boolean ("force-active-vt",
-                                                               NULL,
-                                                               NULL,
-                                                               FALSE,
-                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-
+         g_object_class_install_property (object_class,
+                                          PROP_IS_INITIAL,
+                                          g_param_spec_boolean ("is-initial",
+                                                                NULL,
+                                                                NULL,
+                                                                FALSE,
+                                                                G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
         g_object_class_install_property (object_class,
                                          PROP_SLAVE_COMMAND,
                                          g_param_spec_string ("slave-command",
                                                               "slave command",
                                                               "slave command",
                                                               DEFAULT_SLAVE_COMMAND,
                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
         g_object_class_install_property (object_class,
                                          PROP_STATUS,
                                          g_param_spec_int ("status",
                                                            "status",
                                                            "status",
                                                            -1,
                                                            G_MAXINT,
                                                            GDM_DISPLAY_UNMANAGED,
                                                            G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
 
         g_type_class_add_private (klass, sizeof (GdmDisplayPrivate));
 
         dbus_g_object_type_install_info (GDM_TYPE_DISPLAY, &dbus_glib_gdm_display_object_info);
 }
 
 static void
 gdm_display_init (GdmDisplay *display)
 {
 
         display->priv = GDM_DISPLAY_GET_PRIVATE (display);
 
         display->priv->creation_time = time (NULL);
         display->priv->slave_timer = g_timer_new ();
diff --git a/daemon/gdm-display.h b/daemon/gdm-display.h
index 607ea1d..89cd975 100644
--- a/daemon/gdm-display.h
+++ b/daemon/gdm-display.h
@@ -95,53 +95,56 @@ gboolean            gdm_display_create_authority               (GdmDisplay *disp
 gboolean            gdm_display_prepare                        (GdmDisplay *display);
 gboolean            gdm_display_manage                         (GdmDisplay *display);
 gboolean            gdm_display_finish                         (GdmDisplay *display);
 gboolean            gdm_display_unmanage                       (GdmDisplay *display);
 
 
 /* exported to bus */
 gboolean            gdm_display_get_id                         (GdmDisplay *display,
                                                                 char      **id,
                                                                 GError    **error);
 gboolean            gdm_display_get_remote_hostname            (GdmDisplay *display,
                                                                 char      **hostname,
                                                                 GError    **error);
 gboolean            gdm_display_get_x11_display_number         (GdmDisplay *display,
                                                                 int        *number,
                                                                 GError    **error);
 gboolean            gdm_display_get_x11_display_name           (GdmDisplay *display,
                                                                 char      **x11_display,
                                                                 GError    **error);
 gboolean            gdm_display_get_seat_id                    (GdmDisplay *display,
                                                                 char      **seat_id,
                                                                 GError    **error);
 gboolean            gdm_display_is_local                       (GdmDisplay *display,
                                                                 gboolean   *local,
                                                                 GError    **error);
 gboolean            gdm_display_get_timed_login_details        (GdmDisplay *display,
                                                                 gboolean   *enabled,
                                                                 char      **username,
                                                                 int        *delay,
                                                                 GError    **error);
+gboolean            gdm_display_is_initial                     (GdmDisplay  *display,
+                                                                gboolean    *initial,
+                                                                GError     **error);
 
 /* exported but protected */
 gboolean            gdm_display_get_x11_cookie                 (GdmDisplay *display,
                                                                 GArray     **x11_cookie,
                                                                 GError    **error);
 gboolean            gdm_display_get_x11_authority_file         (GdmDisplay *display,
                                                                 char      **filename,
                                                                 GError    **error);
 gboolean            gdm_display_add_user_authorization         (GdmDisplay *display,
                                                                 const char *username,
                                                                 char      **filename,
                                                                 GError    **error);
 gboolean            gdm_display_remove_user_authorization      (GdmDisplay *display,
                                                                 const char *username,
                                                                 GError    **error);
 gboolean            gdm_display_set_slave_bus_name             (GdmDisplay *display,
                                                                 const char *name,
                                                                 GError    **error);
 
 
 G_END_DECLS
 
 #endif /* __GDM_DISPLAY_H */
diff --git a/daemon/gdm-display.xml b/daemon/gdm-display.xml
index a92e37f..96b09f5 100644
--- a/daemon/gdm-display.xml
+++ b/daemon/gdm-display.xml
@@ -1,44 +1,47 @@
 <!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
 <node>
   <interface name="org.gnome.DisplayManager.Display">
     <method name="GetId">
       <arg name="id" direction="out" type="o"/>
     </method>
     <method name="GetX11DisplayName">
       <arg name="name" direction="out" type="s"/>
     </method>
     <method name="GetX11DisplayNumber">
       <arg name="name" direction="out" type="i"/>
     </method>
     <method name="GetX11Cookie">
       <arg name="x11_cookie" direction="out" type="ay"/>
     </method>
     <method name="GetX11AuthorityFile">
       <arg name="filename" direction="out" type="s"/>
     </method>
     <method name="GetSeatId">
       <arg name="filename" direction="out" type="s"/>
     </method>
     <method name="GetRemoteHostname">
       <arg name="hostname" direction="out" type="s"/>
     </method>
     <method name="IsLocal">
       <arg name="local" direction="out" type="b"/>
     </method>
+    <method name="IsInitial">
+      <arg name="is_initial" direction="out" type="b"/>
+    </method>
     <method name="AddUserAuthorization">
       <arg name="username" direction="in" type="s"/>
       <arg name="filename" direction="out" type="s"/>
     </method>
     <method name="RemoveUserAuthorization">
       <arg name="username" direction="in" type="s"/>
     </method>
     <method name="SetSlaveBusName">
       <arg name="name" direction="in" type="s"/>
     </method>
     <method name="GetTimedLoginDetails">
       <arg name="enabled" direction="out" type="b"/>
       <arg name="username" direction="out" type="s"/>
       <arg name="delay" direction="out" type="i"/>
     </method>
   </interface>
 </node>
diff --git a/daemon/gdm-factory-slave.c b/daemon/gdm-factory-slave.c
index 961817c..70d4a05 100644
--- a/daemon/gdm-factory-slave.c
+++ b/daemon/gdm-factory-slave.c
@@ -669,61 +669,61 @@ on_server_exited (GdmServer       *server,
 static void
 on_server_died (GdmServer       *server,
                 int              signal_number,
                 GdmFactorySlave *slave)
 {
         g_debug ("GdmFactorySlave: server died with signal %d, (%s)",
                  signal_number,
                  g_strsignal (signal_number));
 
         gdm_slave_stopped (GDM_SLAVE (slave));
 }
 
 static gboolean
 gdm_factory_slave_run (GdmFactorySlave *slave)
 {
         char    *display_name;
         char    *auth_file;
         gboolean display_is_local;
 
         g_object_get (slave,
                       "display-is-local", &display_is_local,
                       "display-name", &display_name,
                       "display-x11-authority-file", &auth_file,
                       NULL);
 
         /* if this is local display start a server if one doesn't
          * exist */
         if (display_is_local) {
                 gboolean res;
 
-                slave->priv->server = gdm_server_new (display_name, auth_file);
+                slave->priv->server = gdm_server_new (display_name, auth_file, FALSE);
                 g_signal_connect (slave->priv->server,
                                   "exited",
                                   G_CALLBACK (on_server_exited),
                                   slave);
                 g_signal_connect (slave->priv->server,
                                   "died",
                                   G_CALLBACK (on_server_died),
                                   slave);
                 g_signal_connect (slave->priv->server,
                                   "ready",
                                   G_CALLBACK (on_server_ready),
                                   slave);
 
                 res = gdm_server_start (slave->priv->server);
                 if (! res) {
                         g_warning (_("Could not start the X "
                                      "server (your graphical environment) "
                                      "due to some internal error. "
                                      "Please contact your system administrator "
                                      "or check your syslog to diagnose. "
                                      "In the meantime this display will be "
                                      "disabled.  Please restart GDM when "
                                      "the problem is corrected."));
                         exit (1);
                 }
 
                 g_debug ("GdmFactorySlave: Started X server");
         } else {
                 g_timeout_add (500, (GSourceFunc)idle_connect_to_display, slave);
         }
diff --git a/daemon/gdm-local-display-factory.c b/daemon/gdm-local-display-factory.c
index 5881c05..e33008a 100644
--- a/daemon/gdm-local-display-factory.c
+++ b/daemon/gdm-local-display-factory.c
@@ -38,61 +38,62 @@
 #include "gdm-product-display.h"
 
 #define GDM_LOCAL_DISPLAY_FACTORY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GDM_TYPE_LOCAL_DISPLAY_FACTORY, GdmLocalDisplayFactoryPrivate))
 
 #define CK_SEAT1_PATH                       "/org/freedesktop/ConsoleKit/Seat1"
 
 #define GDM_DBUS_PATH                       "/org/gnome/DisplayManager"
 #define GDM_LOCAL_DISPLAY_FACTORY_DBUS_PATH GDM_DBUS_PATH "/LocalDisplayFactory"
 #define GDM_MANAGER_DBUS_NAME               "org.gnome.DisplayManager.LocalDisplayFactory"
 
 #define MAX_DISPLAY_FAILURES 5
 
 struct GdmLocalDisplayFactoryPrivate
 {
         DBusGConnection *connection;
         DBusGProxy      *proxy;
         GHashTable      *displays;
 
         /* FIXME: this needs to be per seat? */
         guint            num_failures;
 };
 
 enum {
         PROP_0,
 };
 
 static void     gdm_local_display_factory_class_init    (GdmLocalDisplayFactoryClass *klass);
 static void     gdm_local_display_factory_init          (GdmLocalDisplayFactory      *factory);
 static void     gdm_local_display_factory_finalize      (GObject                     *object);
 
-static GdmDisplay *create_display                       (GdmLocalDisplayFactory      *factory);
+static GdmDisplay *create_display                       (GdmLocalDisplayFactory      *factory,
+                                                         gboolean                     is_initial);
 
 static gpointer local_display_factory_object = NULL;
 
 G_DEFINE_TYPE (GdmLocalDisplayFactory, gdm_local_display_factory, GDM_TYPE_DISPLAY_FACTORY)
 
 GQuark
 gdm_local_display_factory_error_quark (void)
 {
         static GQuark ret = 0;
         if (ret == 0) {
                 ret = g_quark_from_static_string ("gdm_local_display_factory_error");
         }
 
         return ret;
 }
 
 static void
 listify_hash (gpointer    key,
               GdmDisplay *display,
               GList     **list)
 {
         *list = g_list_prepend (*list, key);
 }
 
 static int
 sort_nums (gpointer a,
            gpointer b)
 {
         guint32 num_a;
         guint32 num_b;
@@ -256,164 +257,169 @@ gdm_local_display_factory_create_product_display (GdmLocalDisplayFactory *factor
         g_object_set (display, "seat-id", CK_SEAT1_PATH, NULL);
 
         store_display (factory, num, display);
 
         if (! gdm_display_manage (display)) {
                 display = NULL;
                 goto out;
         }
 
         if (! gdm_display_get_id (display, id, NULL)) {
                 display = NULL;
                 goto out;
         }
 
         ret = TRUE;
  out:
         /* ref either held by store or not at all */
         g_object_unref (display);
 
         return ret;
 }
 
 static void
 on_static_display_status_changed (GdmDisplay             *display,
                                   GParamSpec             *arg1,
                                   GdmLocalDisplayFactory *factory)
 {
         int              status;
         GdmDisplayStore *store;
         int              num;
+        gboolean         is_initial = TRUE;
 
         num = -1;
         gdm_display_get_x11_display_number (display, &num, NULL);
         g_assert (num != -1);
 
+        g_object_get (display, "is-initial", &is_initial, NULL);
+
         store = gdm_display_factory_get_display_store (GDM_DISPLAY_FACTORY (factory));
 
         status = gdm_display_get_status (display);
 
         g_debug ("GdmLocalDisplayFactory: static display status changed: %d", status);
         switch (status) {
         case GDM_DISPLAY_FINISHED:
                 /* remove the display number from factory->priv->displays
                    so that it may be reused */
                 g_hash_table_remove (factory->priv->displays, GUINT_TO_POINTER (num));
                 gdm_display_store_remove (store, display);
                 /* reset num failures */
                 factory->priv->num_failures = 0;
-                create_display (factory);
+                create_display (factory, is_initial);
                 break;
         case GDM_DISPLAY_FAILED:
                 /* leave the display number in factory->priv->displays
                    so that it doesn't get reused */
                 gdm_display_store_remove (store, display);
                 factory->priv->num_failures++;
                 if (factory->priv->num_failures > MAX_DISPLAY_FAILURES) {
                         /* oh shit */
                         g_warning ("GdmLocalDisplayFactory: maximum number of X display failures reached: check X server log for errors");
                         /* FIXME: should monitor hardware changes to
                            try again when seats change */
                 } else {
-                        create_display (factory);
+                        create_display (factory, is_initial);
                 }
                 break;
         case GDM_DISPLAY_UNMANAGED:
                 break;
         case GDM_DISPLAY_PREPARED:
                 break;
         case GDM_DISPLAY_MANAGED:
                 break;
         default:
                 g_assert_not_reached ();
                 break;
         }
 }
 
 static GdmDisplay *
-create_display (GdmLocalDisplayFactory *factory)
+create_display (GdmLocalDisplayFactory *factory,
+                gboolean                initial)
 {
         GdmDisplay *display;
         guint32     num;
 
         num = take_next_display_number (factory);
 
 #if 0
         display = gdm_static_factory_display_new (num);
 #else
         display = gdm_static_display_new (num);
 #endif
         if (display == NULL) {
                 g_warning ("Unable to create display: %d", num);
                 return NULL;
         }
 
         /* FIXME: don't hardcode seat1? */
         g_object_set (display, "seat-id", CK_SEAT1_PATH, NULL);
+        g_object_set (display, "is-initial", initial, NULL);
 
         g_signal_connect (display,
                           "notify::status",
                           G_CALLBACK (on_static_display_status_changed),
                           factory);
 
         store_display (factory, num, display);
 
         /* let store own the ref */
         g_object_unref (display);
 
         if (! gdm_display_manage (display)) {
                 gdm_display_unmanage (display);
         }
 
         return display;
 }
 
 static gboolean
 gdm_local_display_factory_start (GdmDisplayFactory *base_factory)
 {
         gboolean                ret;
         GdmLocalDisplayFactory *factory = GDM_LOCAL_DISPLAY_FACTORY (base_factory);
         GdmDisplay             *display;
 
         g_return_val_if_fail (GDM_IS_LOCAL_DISPLAY_FACTORY (factory), FALSE);
 
         ret = TRUE;
 
         if (!g_file_test(X_SERVER, G_FILE_TEST_EXISTS)) {
                 g_spawn_command_line_sync ("/bin/plymouth quit", NULL, NULL, NULL, NULL);
                 g_debug ("GdmLocalDisplayFactory: No X server available, so skipping local display initialization");
 
                 return TRUE;
         }
 
         /* FIXME: use seat configuration */
-        display = create_display (factory);
+        display = create_display (factory, TRUE);
         if (display == NULL) {
                 ret = FALSE;
         }
 
         return ret;
 }
 
 static gboolean
 gdm_local_display_factory_stop (GdmDisplayFactory *base_factory)
 {
         GdmLocalDisplayFactory *factory = GDM_LOCAL_DISPLAY_FACTORY (base_factory);
 
         g_return_val_if_fail (GDM_IS_LOCAL_DISPLAY_FACTORY (factory), FALSE);
 
         return TRUE;
 }
 
 static void
 gdm_local_display_factory_set_property (GObject       *object,
                                         guint          prop_id,
                                         const GValue  *value,
                                         GParamSpec    *pspec)
 {
         switch (prop_id) {
         default:
                 G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
                 break;
         }
 }
 
diff --git a/daemon/gdm-product-slave.c b/daemon/gdm-product-slave.c
index a115f30..d75fe1d 100644
--- a/daemon/gdm-product-slave.c
+++ b/daemon/gdm-product-slave.c
@@ -470,61 +470,61 @@ on_server_exited (GdmServer       *server,
 static void
 on_server_died (GdmServer       *server,
                 int              signal_number,
                 GdmProductSlave *slave)
 {
         g_debug ("GdmProductSlave: server died with signal %d, (%s)",
                  signal_number,
                  g_strsignal (signal_number));
 
         gdm_slave_stopped (GDM_SLAVE (slave));
 }
 
 static gboolean
 gdm_product_slave_create_server (GdmProductSlave *slave)
 {
         char    *display_name;
         char    *auth_file;
         gboolean display_is_local;
 
         g_object_get (slave,
                       "display-is-local", &display_is_local,
                       "display-name", &display_name,
                       "display-x11-authority-file", &auth_file,
                       NULL);
 
         /* if this is local display start a server if one doesn't
          * exist */
         if (display_is_local) {
                 gboolean res;
 
-                slave->priv->server = gdm_server_new (display_name, auth_file);
+                slave->priv->server = gdm_server_new (display_name, auth_file, FALSE);
                 g_signal_connect (slave->priv->server,
                                   "exited",
                                   G_CALLBACK (on_server_exited),
                                   slave);
                 g_signal_connect (slave->priv->server,
                                   "died",
                                   G_CALLBACK (on_server_died),
                                   slave);
                 g_signal_connect (slave->priv->server,
                                   "ready",
                                   G_CALLBACK (on_server_ready),
                                   slave);
 
                 res = gdm_server_start (slave->priv->server);
                 if (! res) {
                         g_warning (_("Could not start the X "
                                      "server (your graphical environment) "
                                      "due to some internal error. "
                                      "Please contact your system administrator "
                                      "or check your syslog to diagnose. "
                                      "In the meantime this display will be "
                                      "disabled.  Please restart GDM when "
                                      "the problem is corrected."));
                         exit (1);
                 }
 
                 g_debug ("GdmProductSlave: Started X server");
         } else {
                 g_timeout_add (500, (GSourceFunc)idle_connect_to_display, slave);
         }
diff --git a/daemon/gdm-server.c b/daemon/gdm-server.c
index 295cb71..0bd62c6 100644
--- a/daemon/gdm-server.c
+++ b/daemon/gdm-server.c
@@ -57,83 +57,85 @@
 
 extern char **environ;
 
 #define GDM_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GDM_TYPE_SERVER, GdmServerPrivate))
 
 /* These are the servstat values, also used as server
  * process exit codes */
 #define SERVER_TIMEOUT 2        /* Server didn't start */
 #define SERVER_DEAD 250         /* Server stopped */
 #define SERVER_PENDING 251      /* Server started but not ready for connections yet */
 #define SERVER_RUNNING 252      /* Server running and ready for connections */
 #define SERVER_ABORT 253        /* Server failed badly. Suspending display. */
 
 #define MAX_LOGS 5
 
 struct GdmServerPrivate
 {
         char    *command;
         GPid     pid;
 
         gboolean disable_tcp;
         int      priority;
         char    *user_name;
         char    *session_args;
 
         char    *log_dir;
         char    *display_name;
         char    *display_device;
         char    *auth_file;
 
-        gboolean is_parented;
+        guint    is_parented : 1;
+        guint    is_initial : 1;
         char    *parent_display_name;
         char    *parent_auth_file;
         char    *chosen_hostname;
 
         guint    child_watch_id;
 };
 
 enum {
         PROP_0,
         PROP_DISPLAY_NAME,
         PROP_DISPLAY_DEVICE,
         PROP_AUTH_FILE,
         PROP_IS_PARENTED,
         PROP_PARENT_DISPLAY_NAME,
         PROP_PARENT_AUTH_FILE,
         PROP_CHOSEN_HOSTNAME,
         PROP_COMMAND,
         PROP_PRIORITY,
         PROP_USER_NAME,
         PROP_SESSION_ARGS,
         PROP_LOG_DIR,
         PROP_DISABLE_TCP,
+        PROP_IS_INITIAL,
 };
 
 enum {
         READY,
         EXITED,
         DIED,
         LAST_SIGNAL
 };
 
 static guint signals [LAST_SIGNAL] = { 0, };
 
 static void     gdm_server_class_init   (GdmServerClass *klass);
 static void     gdm_server_init         (GdmServer      *server);
 static void     gdm_server_finalize     (GObject        *object);
 
 G_DEFINE_TYPE (GdmServer, gdm_server, G_TYPE_OBJECT)
 
 static char *
 _gdm_server_query_ck_for_display_device (GdmServer *server)
 {
         char    *out;
         char    *command;
         int      status;
         gboolean res;
         GError  *error;
 
         g_return_val_if_fail (GDM_IS_SERVER (server), NULL);
 
         error = NULL;
         command = g_strdup_printf (LIBEXECDIR "/ck-get-x11-display-device --display %s",
@@ -651,137 +653,80 @@ gdm_server_spawn (GdmServer  *server,
                                         (char **)env->pdata,
                                         G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD,
                                         (GSpawnChildSetupFunc)server_child_setup,
                                         server,
                                         &server->priv->pid,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &error);
 
         if (! ret) {
                 g_warning ("Could not start command '%s': %s",
                            server->priv->command,
                            error->message);
                 g_error_free (error);
         }
 
         g_strfreev (argv);
         g_ptr_array_foreach (env, (GFunc)g_free, NULL);
         g_ptr_array_free (env, TRUE);
 
         g_debug ("GdmServer: Started X server process %d - waiting for READY", (int)server->priv->pid);
 
         server->priv->child_watch_id = g_child_watch_add (server->priv->pid,
                                                           (GChildWatchFunc)server_child_watch,
                                                           server);
 
         return ret;
 }
 
-static int
-get_active_vt (void)
-{
-        int console_fd;
-        struct vt_stat console_state = { 0 };
-
-        console_fd = open ("/dev/tty0", O_RDONLY | O_NOCTTY);
-
-        if (console_fd < 0) {
-                goto out;
-        }
-
-        if (ioctl (console_fd, VT_GETSTATE, &console_state) < 0) {
-                goto out;
-        }
-
-out:
-        if (console_fd >= 0) {
-                close (console_fd);
-        }
-
-        return console_state.v_active;
-}
-
-static char *
-get_active_vt_as_string (void)
-{
-        int vt;
-
-        vt = get_active_vt ();
-
-        if (vt <= 0) {
-                return NULL;
-        }
-
-        return g_strdup_printf ("vt%d", vt);
-}
-
 /**
  * gdm_server_start:
  * @disp: Pointer to a GdmDisplay structure
  *
  * Starts a local X server. Handles retries and fatal errors properly.
  */
 
 gboolean
 gdm_server_start (GdmServer *server)
 {
         gboolean res;
+        const char *vtarg = NULL;
 
-        /* fork X server process */
-        res = gdm_server_spawn (server, NULL);
-
-        return res;
-}
-
-gboolean
-gdm_server_start_on_active_vt (GdmServer *server)
-{
-        gboolean res;
-        gboolean debug = FALSE;
-        const char *logverbose;
-        char *vt;
-
-        gdm_settings_direct_get_boolean (GDM_KEY_DEBUG, &debug);
-
-        if (debug) {
-                logverbose = " -logverbose 7";
-        } else {
-                logverbose = "";
+        /* Hardcode the VT for the initial X server, but nothing else */
+        if (server->priv->is_initial) {
+                vtarg = "vt" GDM_INITIAL_VT;
         }
 
-        g_free (server->priv->command);
-        server->priv->command = g_strdup_printf (X_SERVER " -nr -verbose -audit 4 %s", logverbose);
-        vt = get_active_vt_as_string ();
-        res = gdm_server_spawn (server, vt);
-        g_free (vt);
+        /* fork X server process */
+        res = gdm_server_spawn (server, vtarg);
 
         return res;
 }
 
 static void
 server_died (GdmServer *server)
 {
         int exit_status;
 
         g_debug ("GdmServer: Waiting on process %d", server->priv->pid);
         exit_status = gdm_wait_on_pid (server->priv->pid);
 
         if (WIFEXITED (exit_status) && (WEXITSTATUS (exit_status) != 0)) {
                 g_debug ("GdmServer: Wait on child process failed");
         } else {
                 /* exited normally */
         }
 
         g_spawn_close_pid (server->priv->pid);
         server->priv->pid = -1;
 
         if (server->priv->display_device != NULL) {
                 g_free (server->priv->display_device);
                 server->priv->display_device = NULL;
                 g_object_notify (G_OBJECT (server), "display-device");
         }
 
         g_debug ("GdmServer: Server died");
 }
 
@@ -817,115 +762,128 @@ _gdm_server_set_display_name (GdmServer  *server,
                               const char *name)
 {
         g_free (server->priv->display_name);
         server->priv->display_name = g_strdup (name);
 }
 
 static void
 _gdm_server_set_auth_file (GdmServer  *server,
                            const char *auth_file)
 {
         g_free (server->priv->auth_file);
         server->priv->auth_file = g_strdup (auth_file);
 }
 
 static void
 _gdm_server_set_user_name (GdmServer  *server,
                            const char *name)
 {
         g_free (server->priv->user_name);
         server->priv->user_name = g_strdup (name);
 }
 
 static void
 _gdm_server_set_disable_tcp (GdmServer  *server,
                              gboolean    disabled)
 {
         server->priv->disable_tcp = disabled;
 }
 
 static void
+_gdm_server_set_is_initial (GdmServer  *server,
+                            gboolean    initial)
+{
+        server->priv->is_initial = initial;
+}
+
+static void
 gdm_server_set_property (GObject      *object,
                          guint         prop_id,
                          const GValue *value,
                          GParamSpec   *pspec)
 {
         GdmServer *self;
 
         self = GDM_SERVER (object);
 
         switch (prop_id) {
         case PROP_DISPLAY_NAME:
                 _gdm_server_set_display_name (self, g_value_get_string (value));
                 break;
         case PROP_AUTH_FILE:
                 _gdm_server_set_auth_file (self, g_value_get_string (value));
                 break;
         case PROP_USER_NAME:
                 _gdm_server_set_user_name (self, g_value_get_string (value));
                 break;
         case PROP_DISABLE_TCP:
                 _gdm_server_set_disable_tcp (self, g_value_get_boolean (value));
                 break;
+        case PROP_IS_INITIAL:
+                _gdm_server_set_is_initial (self, g_value_get_boolean (value));
+                break;
         default:
                 G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
                 break;
         }
 }
 
 static void
 gdm_server_get_property (GObject    *object,
                          guint       prop_id,
                          GValue     *value,
                          GParamSpec *pspec)
 {
         GdmServer *self;
 
         self = GDM_SERVER (object);
 
         switch (prop_id) {
         case PROP_DISPLAY_NAME:
                 g_value_set_string (value, self->priv->display_name);
                 break;
         case PROP_DISPLAY_DEVICE:
                 g_value_take_string (value,
                                      gdm_server_get_display_device (self));
                 break;
         case PROP_AUTH_FILE:
                 g_value_set_string (value, self->priv->auth_file);
                 break;
         case PROP_USER_NAME:
                 g_value_set_string (value, self->priv->user_name);
                 break;
         case PROP_DISABLE_TCP:
                 g_value_set_boolean (value, self->priv->disable_tcp);
                 break;
+        case PROP_IS_INITIAL:
+                g_value_set_boolean (value, self->priv->is_initial);
+                break;
         default:
                 G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
                 break;
         }
 }
 
 static GObject *
 gdm_server_constructor (GType                  type,
                         guint                  n_construct_properties,
                         GObjectConstructParam *construct_properties)
 {
         GdmServer      *server;
 
         server = GDM_SERVER (G_OBJECT_CLASS (gdm_server_parent_class)->constructor (type,
                                                                                     n_construct_properties,
                                                                                     construct_properties));
         return G_OBJECT (server);
 }
 
 static void
 gdm_server_class_init (GdmServerClass *klass)
 {
         GObjectClass    *object_class = G_OBJECT_CLASS (klass);
 
         object_class->get_property = gdm_server_get_property;
         object_class->set_property = gdm_server_set_property;
         object_class->constructor = gdm_server_constructor;
         object_class->finalize = gdm_server_finalize;
 
         g_type_class_add_private (klass, sizeof (GdmServerPrivate));
@@ -972,100 +930,108 @@ gdm_server_class_init (GdmServerClass *klass)
                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
         g_object_class_install_property (object_class,
                                          PROP_DISPLAY_DEVICE,
                                          g_param_spec_string ("display-device",
                                                               "Display Device",
                                                               "Path to terminal display is running on",
                                                               NULL,
                                                               G_PARAM_READABLE));
         g_object_class_install_property (object_class,
                                          PROP_AUTH_FILE,
                                          g_param_spec_string ("auth-file",
                                                               "Authorization File",
                                                               "Path to X authorization file",
                                                               NULL,
                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
 
         g_object_class_install_property (object_class,
                                          PROP_USER_NAME,
                                          g_param_spec_string ("user-name",
                                                               "user name",
                                                               "user name",
                                                               NULL,
                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
         g_object_class_install_property (object_class,
                                          PROP_DISABLE_TCP,
                                          g_param_spec_boolean ("disable-tcp",
                                                                NULL,
                                                                NULL,
                                                                TRUE,
                                                                G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_IS_INITIAL,
+                                         g_param_spec_boolean ("is-initial",
+                                                               NULL,
+                                                               NULL,
+                                                               FALSE,
+                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
 
 }
 
 static void
 gdm_server_init (GdmServer *server)
 {
         gboolean debug = FALSE;
         const char *logverbose;
-        char *vt;
 
         server->priv = GDM_SERVER_GET_PRIVATE (server);
 
         gdm_settings_direct_get_boolean (GDM_KEY_DEBUG, &debug);
 
         if (debug) {
                 logverbose = " -logverbose 7";
         } else {
                 logverbose = "";
         }
 
         server->priv->pid = -1;
         server->priv->command = g_strdup_printf (X_SERVER " -br -verbose -audit 4 %s", logverbose);
         server->priv->log_dir = g_strdup (LOGDIR);
 
         add_ready_handler (server);
 }
 
 static void
 gdm_server_finalize (GObject *object)
 {
         GdmServer *server;
 
         g_return_if_fail (object != NULL);
         g_return_if_fail (GDM_IS_SERVER (object));
 
         server = GDM_SERVER (object);
 
         g_return_if_fail (server->priv != NULL);
 
         remove_ready_handler (server);
 
         gdm_server_stop (server);
 
         g_free (server->priv->command);
         g_free (server->priv->user_name);
         g_free (server->priv->session_args);
         g_free (server->priv->log_dir);
         g_free (server->priv->display_name);
         g_free (server->priv->display_device);
         g_free (server->priv->auth_file);
         g_free (server->priv->parent_display_name);
         g_free (server->priv->parent_auth_file);
         g_free (server->priv->chosen_hostname);
 
         G_OBJECT_CLASS (gdm_server_parent_class)->finalize (object);
 }
 
 GdmServer *
 gdm_server_new (const char *display_name,
-                const char *auth_file)
+                const char *auth_file,
+                gboolean    initial)
 {
         GObject *object;
 
         object = g_object_new (GDM_TYPE_SERVER,
                                "display-name", display_name,
                                "auth-file", auth_file,
+                               "is-initial", initial,
                                NULL);
 
         return GDM_SERVER (object);
 }
diff --git a/daemon/gdm-server.h b/daemon/gdm-server.h
index bd6c60a..ce6d454 100644
--- a/daemon/gdm-server.h
+++ b/daemon/gdm-server.h
@@ -27,39 +27,39 @@
 G_BEGIN_DECLS
 
 #define GDM_TYPE_SERVER         (gdm_server_get_type ())
 #define GDM_SERVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GDM_TYPE_SERVER, GdmServer))
 #define GDM_SERVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GDM_TYPE_SERVER, GdmServerClass))
 #define GDM_IS_SERVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GDM_TYPE_SERVER))
 #define GDM_IS_SERVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GDM_TYPE_SERVER))
 #define GDM_SERVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GDM_TYPE_SERVER, GdmServerClass))
 
 typedef struct GdmServerPrivate GdmServerPrivate;
 
 typedef struct
 {
         GObject           parent;
         GdmServerPrivate *priv;
 } GdmServer;
 
 typedef struct
 {
         GObjectClass   parent_class;
 
         void (* ready)             (GdmServer *server);
         void (* exited)            (GdmServer *server,
                                     int        exit_code);
         void (* died)              (GdmServer *server,
                                     int        signal_number);
 } GdmServerClass;
 
 GType               gdm_server_get_type  (void);
 GdmServer *         gdm_server_new       (const char *display_id,
-                                          const char *auth_file);
+                                          const char *auth_file,
+                                          gboolean    initial);
 gboolean            gdm_server_start     (GdmServer   *server);
-gboolean            gdm_server_start_on_active_vt (GdmServer   *server);
 gboolean            gdm_server_stop      (GdmServer   *server);
 char *              gdm_server_get_display_device (GdmServer *server);
 
 G_END_DECLS
 
 #endif /* __GDM_SERVER_H */
diff --git a/daemon/gdm-simple-slave.c b/daemon/gdm-simple-slave.c
index dcf0c2c..6eeb050 100644
--- a/daemon/gdm-simple-slave.c
+++ b/daemon/gdm-simple-slave.c
@@ -1480,109 +1480,106 @@ on_server_exited (GdmServer      *server,
 
         gdm_slave_stopped (GDM_SLAVE (slave));
 
         if (slave->priv->plymouth_is_running) {
                 plymouth_quit_without_transition (slave);
         }
 }
 
 static void
 on_server_died (GdmServer      *server,
                 int             signal_number,
                 GdmSimpleSlave *slave)
 {
         g_debug ("GdmSimpleSlave: server died with signal %d, (%s)",
                  signal_number,
                  g_strsignal (signal_number));
 
         gdm_slave_stopped (GDM_SLAVE (slave));
 
         if (slave->priv->plymouth_is_running) {
                 plymouth_quit_without_transition (slave);
         }
 }
 
 static gboolean
 gdm_simple_slave_run (GdmSimpleSlave *slave)
 {
         char    *display_name;
         char    *auth_file;
         gboolean display_is_local;
-        gboolean force_active_vt;
+        gboolean display_is_initial;
 
         g_object_get (slave,
                       "display-is-local", &display_is_local,
                       "display-name", &display_name,
                       "display-x11-authority-file", &auth_file,
-                      "force-active-vt", &force_active_vt,
+                      "display-is-initial", &display_is_initial,
                       NULL);
 
         /* if this is local display start a server if one doesn't
          * exist */
         if (display_is_local) {
                 gboolean res;
                 gboolean disable_tcp;
 
-                slave->priv->server = gdm_server_new (display_name, auth_file);
+                slave->priv->server = gdm_server_new (display_name, auth_file, display_is_initial);
 
                 disable_tcp = TRUE;
                 if (gdm_settings_client_get_boolean (GDM_KEY_DISALLOW_TCP,
                                                      &disable_tcp)) {
                         g_object_set (slave->priv->server,
                                       "disable-tcp", disable_tcp,
                                       NULL);
                 }
 
                 g_signal_connect (slave->priv->server,
                                   "exited",
                                   G_CALLBACK (on_server_exited),
                                   slave);
                 g_signal_connect (slave->priv->server,
                                   "died",
                                   G_CALLBACK (on_server_died),
                                   slave);
                 g_signal_connect (slave->priv->server,
                                   "ready",
                                   G_CALLBACK (on_server_ready),
                                   slave);
 
                 slave->priv->plymouth_is_running = plymouth_is_running ();
 
                 if (slave->priv->plymouth_is_running) {
                         plymouth_prepare_for_transition (slave);
-                        res = gdm_server_start_on_active_vt (slave->priv->server);
-                } else {
-                        if (force_active_vt)
-                                res = gdm_server_start_on_active_vt (slave->priv->server);
-                        else
-                                res = gdm_server_start (slave->priv->server);
                 }
+
+                res = gdm_server_start (slave->priv->server);
+
                 if (! res) {
                         g_warning (_("Could not start the X "
                                      "server (your graphical environment) "
                                      "due to some internal error. "
                                      "Please contact your system administrator "
                                      "or check your syslog to diagnose. "
                                      "In the meantime this display will be "
                                      "disabled.  Please restart GDM when "
                                      "the problem is corrected."));
                         if (slave->priv->plymouth_is_running) {
                                 plymouth_quit_without_transition (slave);
                         }
                         exit (1);
                 }
 
                 g_debug ("GdmSimpleSlave: Started X server");
         } else {
                 g_timeout_add (500, (GSourceFunc)idle_connect_to_display, slave);
         }
 
         g_free (display_name);
         g_free (auth_file);
 
         return TRUE;
 }
 
 static gboolean
 gdm_simple_slave_start (GdmSlave *slave)
 {
         GDM_SLAVE_CLASS (gdm_simple_slave_parent_class)->start (slave);
@@ -1679,42 +1676,40 @@ gdm_simple_slave_class_init (GdmSimpleSlaveClass *klass)
 
 static void
 gdm_simple_slave_init (GdmSimpleSlave *slave)
 {
         slave->priv = GDM_SIMPLE_SLAVE_GET_PRIVATE (slave);
 }
 
 static void
 gdm_simple_slave_finalize (GObject *object)
 {
         GdmSimpleSlave *simple_slave;
 
         g_return_if_fail (object != NULL);
         g_return_if_fail (GDM_IS_SIMPLE_SLAVE (object));
 
         simple_slave = GDM_SIMPLE_SLAVE (object);
 
         g_return_if_fail (simple_slave->priv != NULL);
 
         gdm_simple_slave_stop (GDM_SLAVE (simple_slave));
 
         if (simple_slave->priv->greeter_reset_id > 0) {
                 g_source_remove (simple_slave->priv->greeter_reset_id);
                 simple_slave->priv->greeter_reset_id = 0;
         }
 
         G_OBJECT_CLASS (gdm_simple_slave_parent_class)->finalize (object);
 }
 
 GdmSlave *
-gdm_simple_slave_new (const char *id,
-                      gboolean    force_active_vt)
+gdm_simple_slave_new (const char *id)
 {
         GObject *object;
 
         object = g_object_new (GDM_TYPE_SIMPLE_SLAVE,
                                "display-id", id,
-                               "force-active-vt", force_active_vt,
                                NULL);
 
         return GDM_SLAVE (object);
 }
diff --git a/daemon/gdm-simple-slave.h b/daemon/gdm-simple-slave.h
index e9aa624..1f1aa1d 100644
--- a/daemon/gdm-simple-slave.h
+++ b/daemon/gdm-simple-slave.h
@@ -21,36 +21,35 @@
 
 #ifndef __GDM_SIMPLE_SLAVE_H
 #define __GDM_SIMPLE_SLAVE_H
 
 #include <glib-object.h>
 #include "gdm-slave.h"
 
 G_BEGIN_DECLS
 
 #define GDM_TYPE_SIMPLE_SLAVE         (gdm_simple_slave_get_type ())
 #define GDM_SIMPLE_SLAVE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GDM_TYPE_SIMPLE_SLAVE, GdmSimpleSlave))
 #define GDM_SIMPLE_SLAVE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GDM_TYPE_SIMPLE_SLAVE, GdmSimpleSlaveClass))
 #define GDM_IS_SIMPLE_SLAVE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GDM_TYPE_SIMPLE_SLAVE))
 #define GDM_IS_SIMPLE_SLAVE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GDM_TYPE_SIMPLE_SLAVE))
 #define GDM_SIMPLE_SLAVE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GDM_TYPE_SIMPLE_SLAVE, GdmSimpleSlaveClass))
 
 typedef struct GdmSimpleSlavePrivate GdmSimpleSlavePrivate;
 
 typedef struct
 {
         GdmSlave               parent;
         GdmSimpleSlavePrivate *priv;
 } GdmSimpleSlave;
 
 typedef struct
 {
         GdmSlaveClass   parent_class;
 } GdmSimpleSlaveClass;
 
 GType               gdm_simple_slave_get_type   (void);
-GdmSlave *          gdm_simple_slave_new        (const char       *id,
-                                                 gboolean          force_active_vt);
+GdmSlave *          gdm_simple_slave_new        (const char       *id);
 
 G_END_DECLS
 
 #endif /* __GDM_SIMPLE_SLAVE_H */
diff --git a/daemon/gdm-slave.c b/daemon/gdm-slave.c
index 4a394f3..869448a 100644
--- a/daemon/gdm-slave.c
+++ b/daemon/gdm-slave.c
@@ -69,75 +69,77 @@
 
 #define GDM_DBUS_NAME              "org.gnome.DisplayManager"
 #define GDM_DBUS_DISPLAY_INTERFACE "org.gnome.DisplayManager.Display"
 
 #define MAX_CONNECT_ATTEMPTS 10
 
 struct GdmSlavePrivate
 {
         char            *id;
         GPid             pid;
         guint            output_watch_id;
         guint            error_watch_id;
 
         Display         *server_display;
 
         /* cached display values */
         char            *display_id;
         char            *display_name;
         int              display_number;
         char            *display_hostname;
         gboolean         display_is_local;
         gboolean         display_is_parented;
         gboolean         force_active_vt;
         char            *display_seat_id;
         char            *display_x11_authority_file;
         char            *parent_display_name;
         char            *parent_display_x11_authority_file;
         char            *windowpath;
 
         GArray          *display_x11_cookie;
+        gboolean         display_is_initial;
 
         DBusGProxy      *display_proxy;
         DBusGConnection *connection;
 };
 
 enum {
         PROP_0,
         PROP_DISPLAY_ID,
         PROP_DISPLAY_NAME,
         PROP_DISPLAY_NUMBER,
         PROP_DISPLAY_HOSTNAME,
         PROP_DISPLAY_IS_LOCAL,
         PROP_FORCE_ACTIVE_VT,
         PROP_DISPLAY_SEAT_ID,
-        PROP_DISPLAY_X11_AUTHORITY_FILE
+        PROP_DISPLAY_X11_AUTHORITY_FILE,
+        PROP_DISPLAY_IS_INITIAL,
 };
 
 enum {
         STOPPED,
         LAST_SIGNAL
 };
 
 static guint signals [LAST_SIGNAL] = { 0, };
 
 static void     gdm_slave_class_init    (GdmSlaveClass *klass);
 static void     gdm_slave_init          (GdmSlave      *slave);
 static void     gdm_slave_finalize      (GObject       *object);
 
 G_DEFINE_ABSTRACT_TYPE (GdmSlave, gdm_slave, G_TYPE_OBJECT)
 
 #define CURSOR_WATCH XC_watch
 
 static void
 gdm_slave_whack_temp_auth_file (GdmSlave *slave)
 {
 #if 0
         uid_t old;
 
         old = geteuid ();
         if (old != 0)
                 seteuid (0);
         if (d->parent_temp_auth_file != NULL) {
                 VE_IGNORE_EINTR (g_unlink (d->parent_temp_auth_file));
         }
         g_free (d->parent_temp_auth_file);
@@ -885,60 +887,78 @@ gdm_slave_real_start (GdmSlave *slave)
                                  G_TYPE_INVALID);
         if (! res) {
                 if (error != NULL) {
                         g_warning ("Failed to get value: %s", error->message);
                         g_error_free (error);
                 } else {
                         g_warning ("Failed to get value");
                 }
 
                 return FALSE;
         }
 
         error = NULL;
         res = dbus_g_proxy_call (slave->priv->display_proxy,
                                  "GetSeatId",
                                  &error,
                                  G_TYPE_INVALID,
                                  G_TYPE_STRING, &slave->priv->display_seat_id,
                                  G_TYPE_INVALID);
         if (! res) {
                 if (error != NULL) {
                         g_warning ("Failed to get value: %s", error->message);
                         g_error_free (error);
                 } else {
                         g_warning ("Failed to get value");
                 }
 
                 return FALSE;
         }
 
+        error = NULL;
+        res = dbus_g_proxy_call (slave->priv->display_proxy,
+                                 "IsInitial",
+                                 &error,
+                                 G_TYPE_INVALID,
+                                 G_TYPE_BOOLEAN, &slave->priv->display_is_initial,
+                                 G_TYPE_INVALID);
+        if (! res) {
+                if (error != NULL) {
+                        g_warning ("Failed to get value: %s", error->message);
+                        g_error_free (error);
+                } else {
+                        g_warning ("Failed to get value");
+                }
+
+                return FALSE;
+        }
+
         return TRUE;
 }
 
 static gboolean
 gdm_slave_real_stop (GdmSlave *slave)
 {
         g_debug ("GdmSlave: Stopping slave");
 
         if (slave->priv->display_proxy != NULL) {
                 g_object_unref (slave->priv->display_proxy);
         }
 
         return TRUE;
 }
 
 gboolean
 gdm_slave_start (GdmSlave *slave)
 {
         gboolean ret;
 
         g_return_val_if_fail (GDM_IS_SLAVE (slave), FALSE);
 
         g_debug ("GdmSlave: starting slave");
 
         g_object_ref (slave);
         ret = GDM_SLAVE_GET_CLASS (slave)->start (slave);
         g_object_unref (slave);
 
         return ret;
 }
@@ -1578,141 +1598,141 @@ _gdm_slave_set_display_hostname (GdmSlave   *slave,
                                  const char *name)
 {
         g_free (slave->priv->display_hostname);
         slave->priv->display_hostname = g_strdup (name);
 }
 
 static void
 _gdm_slave_set_display_x11_authority_file (GdmSlave   *slave,
                                            const char *name)
 {
         g_free (slave->priv->display_x11_authority_file);
         slave->priv->display_x11_authority_file = g_strdup (name);
 }
 
 static void
 _gdm_slave_set_display_seat_id (GdmSlave   *slave,
                                 const char *id)
 {
         g_free (slave->priv->display_seat_id);
         slave->priv->display_seat_id = g_strdup (id);
 }
 
 static void
 _gdm_slave_set_display_is_local (GdmSlave   *slave,
                                  gboolean    is)
 {
         slave->priv->display_is_local = is;
 }
 
 static void
-_gdm_slave_set_force_active_vt (GdmSlave   *slave,
-                                gboolean    force_active_vt)
+_gdm_slave_set_display_is_initial (GdmSlave   *slave,
+                                   gboolean    is)
 {
-        slave->priv->force_active_vt = force_active_vt;
+        slave->priv->display_is_initial = is;
 }
 
 static void
 gdm_slave_set_property (GObject      *object,
                         guint         prop_id,
                         const GValue *value,
                         GParamSpec   *pspec)
 {
         GdmSlave *self;
 
         self = GDM_SLAVE (object);
 
         switch (prop_id) {
         case PROP_DISPLAY_ID:
                 _gdm_slave_set_display_id (self, g_value_get_string (value));
                 break;
         case PROP_DISPLAY_NAME:
                 _gdm_slave_set_display_name (self, g_value_get_string (value));
                 break;
         case PROP_DISPLAY_NUMBER:
                 _gdm_slave_set_display_number (self, g_value_get_int (value));
                 break;
         case PROP_DISPLAY_HOSTNAME:
                 _gdm_slave_set_display_hostname (self, g_value_get_string (value));
                 break;
         case PROP_DISPLAY_SEAT_ID:
                 _gdm_slave_set_display_seat_id (self, g_value_get_string (value));
                 break;
         case PROP_DISPLAY_X11_AUTHORITY_FILE:
                 _gdm_slave_set_display_x11_authority_file (self, g_value_get_string (value));
                 break;
         case PROP_DISPLAY_IS_LOCAL:
                 _gdm_slave_set_display_is_local (self, g_value_get_boolean (value));
                 break;
-        case PROP_FORCE_ACTIVE_VT:
-                _gdm_slave_set_force_active_vt (self, g_value_get_boolean (value));
+        case PROP_DISPLAY_IS_INITIAL:
+                _gdm_slave_set_display_is_initial (self, g_value_get_boolean (value));
                 break;
         default:
                 G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
                 break;
         }
 }
 
 static void
 gdm_slave_get_property (GObject    *object,
                         guint       prop_id,
                         GValue     *value,
                         GParamSpec *pspec)
 {
         GdmSlave *self;
 
         self = GDM_SLAVE (object);
 
         switch (prop_id) {
         case PROP_DISPLAY_ID:
                 g_value_set_string (value, self->priv->display_id);
                 break;
         case PROP_DISPLAY_NAME:
                 g_value_set_string (value, self->priv->display_name);
                 break;
         case PROP_DISPLAY_NUMBER:
                 g_value_set_int (value, self->priv->display_number);
                 break;
         case PROP_DISPLAY_HOSTNAME:
                 g_value_set_string (value, self->priv->display_hostname);
                 break;
         case PROP_DISPLAY_SEAT_ID:
                 g_value_set_string (value, self->priv->display_seat_id);
                 break;
         case PROP_DISPLAY_X11_AUTHORITY_FILE:
                 g_value_set_string (value, self->priv->display_x11_authority_file);
                 break;
         case PROP_DISPLAY_IS_LOCAL:
                 g_value_set_boolean (value, self->priv->display_is_local);
                 break;
-        case PROP_FORCE_ACTIVE_VT:
-                g_value_set_boolean (value, self->priv->force_active_vt);
+        case PROP_DISPLAY_IS_INITIAL:
+                g_value_set_boolean (value, self->priv->display_is_initial);
                 break;
         default:
                 G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
                 break;
         }
 }
 
 static gboolean
 register_slave (GdmSlave *slave)
 {
         GError *error;
 
         error = NULL;
         slave->priv->connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
         if (slave->priv->connection == NULL) {
                 if (error != NULL) {
                         g_critical ("error getting system bus: %s", error->message);
                         g_error_free (error);
                 }
                 exit (1);
         }
 
         dbus_g_connection_register_g_object (slave->priv->connection, slave->priv->id, G_OBJECT (slave));
 
         return TRUE;
 }
 
 static GObject *
 gdm_slave_constructor (GType                  type,
                        guint                  n_construct_properties,
@@ -1784,67 +1804,66 @@ gdm_slave_class_init (GdmSlaveClass *klass)
                                                            -1,
                                                            G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
         g_object_class_install_property (object_class,
                                          PROP_DISPLAY_HOSTNAME,
                                          g_param_spec_string ("display-hostname",
                                                               "display hostname",
                                                               "display hostname",
                                                               NULL,
                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
         g_object_class_install_property (object_class,
                                          PROP_DISPLAY_SEAT_ID,
                                          g_param_spec_string ("display-seat-id",
                                                               "",
                                                               "",
                                                               NULL,
                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
         g_object_class_install_property (object_class,
                                          PROP_DISPLAY_X11_AUTHORITY_FILE,
                                          g_param_spec_string ("display-x11-authority-file",
                                                               "",
                                                               "",
                                                               NULL,
                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
         g_object_class_install_property (object_class,
                                          PROP_DISPLAY_IS_LOCAL,
                                          g_param_spec_boolean ("display-is-local",
                                                                "display is local",
                                                                "display is local",
                                                                TRUE,
                                                                G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
-
         g_object_class_install_property (object_class,
-                                         PROP_FORCE_ACTIVE_VT,
-                                         g_param_spec_boolean ("force-active-vt",
-                                                               "Force Active VT",
-                                                               "Force display to active VT",
-                                                               TRUE,
+                                         PROP_DISPLAY_IS_INITIAL,
+                                         g_param_spec_boolean ("display-is-initial",
+                                                               NULL,
+                                                               NULL,
+                                                               FALSE,
                                                                G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
 
         signals [STOPPED] =
                 g_signal_new ("stopped",
                               G_TYPE_FROM_CLASS (object_class),
                               G_SIGNAL_RUN_LAST,
                               G_STRUCT_OFFSET (GdmSlaveClass, stopped),
                               NULL,
                               NULL,
                               g_cclosure_marshal_VOID__VOID,
                               G_TYPE_NONE,
                               0);
 
         dbus_g_object_type_install_info (GDM_TYPE_SLAVE, &dbus_glib_gdm_slave_object_info);
 }
 
 static void
 gdm_slave_init (GdmSlave *slave)
 {
 
         slave->priv = GDM_SLAVE_GET_PRIVATE (slave);
 
         slave->priv->pid = -1;
 }
 
 static void
 gdm_slave_finalize (GObject *object)
 {
         GdmSlave *slave;
 
diff --git a/daemon/gdm-static-display.c b/daemon/gdm-static-display.c
index 8a96b42..a747ee3 100644
--- a/daemon/gdm-static-display.c
+++ b/daemon/gdm-static-display.c
@@ -59,81 +59,64 @@ static void     gdm_static_display_finalize     (GObject              *object);
 G_DEFINE_TYPE (GdmStaticDisplay, gdm_static_display, GDM_TYPE_DISPLAY)
 
 static gboolean
 gdm_static_display_create_authority (GdmDisplay *display)
 {
         g_return_val_if_fail (GDM_IS_DISPLAY (display), FALSE);
 
         GDM_DISPLAY_CLASS (gdm_static_display_parent_class)->create_authority (display);
 
         return TRUE;
 }
 
 static gboolean
 gdm_static_display_add_user_authorization (GdmDisplay *display,
                                            const char *username,
                                            char      **filename,
                                            GError    **error)
 {
         return GDM_DISPLAY_CLASS (gdm_static_display_parent_class)->add_user_authorization (display, username, filename, error);
 }
 
 static gboolean
 gdm_static_display_remove_user_authorization (GdmDisplay *display,
                                               const char *username,
                                               GError    **error)
 {
         return GDM_DISPLAY_CLASS (gdm_static_display_parent_class)->remove_user_authorization (display, username, error);
 }
 
 static gboolean
-triggered_to_force_display_on_active_vt (void)
-{
-        gboolean should_force_display_on_active_vt;
-
-        should_force_display_on_active_vt = g_file_test (GDM_SPOOL_DIR "/force-display-on-active-vt",
-                                                         G_FILE_TEST_EXISTS);
-        g_unlink (GDM_SPOOL_DIR "/force-display-on-active-vt");
-
-        return should_force_display_on_active_vt;
-}
-
-static gboolean
 gdm_static_display_manage (GdmDisplay *display)
 {
         g_return_val_if_fail (GDM_IS_DISPLAY (display), FALSE);
 
-        if (triggered_to_force_display_on_active_vt ()) {
-                g_object_set (display, "force-active-vt", TRUE, NULL);
-        } else {
-                g_object_set (display, "force-active-vt", FALSE, NULL);
-        }
         GDM_DISPLAY_CLASS (gdm_static_display_parent_class)->manage (display);
 
         return TRUE;
 }
 
 static gboolean
 gdm_static_display_finish (GdmDisplay *display)
 {
         int status;
 
         g_return_val_if_fail (GDM_IS_DISPLAY (display), FALSE);
 
         /* Don't call parent's finish since we don't ever
            want to be put in the FINISHED state */
 
         /* restart static displays */
         gdm_display_unmanage (display);
 
         status = gdm_display_get_status (display);
         if (status != GDM_DISPLAY_FAILED) {
                 gdm_display_manage (display);
         }
 
         return TRUE;
 }
 
 static gboolean
 gdm_static_display_unmanage (GdmDisplay *display)
 {
         g_return_val_if_fail (GDM_IS_DISPLAY (display), FALSE);
diff --git a/daemon/simple-slave-main.c b/daemon/simple-slave-main.c
index ec94341..eed1742 100644
--- a/daemon/simple-slave-main.c
+++ b/daemon/simple-slave-main.c
@@ -150,65 +150,63 @@ on_slave_stopped (GdmSlave   *slave,
                   GMainLoop  *main_loop)
 {
         g_debug ("slave finished");
         gdm_return_code = 0;
         g_main_loop_quit (main_loop);
 }
 
 static gboolean
 is_debug_set (void)
 {
         gboolean debug = FALSE;
 
         /* enable debugging for unstable builds */
         if (gdm_is_version_unstable ()) {
                 return TRUE;
         }
 
         gdm_settings_direct_get_boolean (GDM_KEY_DEBUG, &debug);
         return debug;
 }
 
 int
 main (int    argc,
       char **argv)
 {
         GMainLoop        *main_loop;
         GOptionContext   *context;
         DBusGConnection  *connection;
         GdmSlave         *slave;
         static char      *display_id = NULL;
-        static gboolean   force_active_vt = FALSE;
         GdmSignalHandler *signal_handler;
         static GOptionEntry entries []   = {
                 { "display-id", 0, 0, G_OPTION_ARG_STRING, &display_id, N_("Display ID"), N_("ID") },
-                { "force-active-vt", 0, 0, G_OPTION_ARG_NONE, &force_active_vt, N_("Force X to start on active vt"), NULL },
                 { NULL }
         };
 
         bindtextdomain (GETTEXT_PACKAGE, GNOMELOCALEDIR);
         textdomain (GETTEXT_PACKAGE);
         setlocale (LC_ALL, "");
 
         gdm_set_fatal_warnings_if_unstable ();
 
         g_type_init ();
 
         context = g_option_context_new (_("GNOME Display Manager Slave"));
         g_option_context_add_main_entries (context, entries, NULL);
 
         g_option_context_parse (context, &argc, &argv, NULL);
         g_option_context_free (context);
 
         /* For debugging */
         /*sleep (10);*/
 
         connection = get_system_bus ();
         if (connection == NULL) {
                 goto out;
         }
 
         gdm_xerrors_init ();
         gdm_log_init ();
 
         settings = gdm_settings_new ();
         if (settings == NULL) {
@@ -223,58 +221,58 @@ main (int    argc,
 
         gdm_log_set_debug (is_debug_set ());
 
         if (display_id == NULL) {
                 g_critical ("No display ID set");
                 exit (1);
         }
 
         if (! gdm_settings_client_init (GDMCONFDIR "/gdm.schemas", "/")) {
                 g_critical ("Unable to initialize settings client");
                 exit (1);
         }
 
         main_loop = g_main_loop_new (NULL, FALSE);
 
         signal_handler = gdm_signal_handler_new ();
         gdm_signal_handler_set_fatal_func (signal_handler,
                                            (GDestroyNotify)g_main_loop_quit,
                                            main_loop);
         gdm_signal_handler_add (signal_handler, SIGTERM, signal_cb, NULL);
         gdm_signal_handler_add (signal_handler, SIGINT, signal_cb, NULL);
         gdm_signal_handler_add (signal_handler, SIGILL, signal_cb, NULL);
         gdm_signal_handler_add (signal_handler, SIGBUS, signal_cb, NULL);
         gdm_signal_handler_add (signal_handler, SIGFPE, signal_cb, NULL);
         gdm_signal_handler_add (signal_handler, SIGHUP, signal_cb, NULL);
         gdm_signal_handler_add (signal_handler, SIGSEGV, signal_cb, NULL);
         gdm_signal_handler_add (signal_handler, SIGABRT, signal_cb, NULL);
         gdm_signal_handler_add (signal_handler, SIGUSR1, signal_cb, NULL);
         gdm_signal_handler_add (signal_handler, SIGUSR2, signal_cb, NULL);
 
-        slave = gdm_simple_slave_new (display_id, force_active_vt);
+        slave = gdm_simple_slave_new (display_id);
         if (slave == NULL) {
                 goto out;
         }
         g_signal_connect (slave,
                           "stopped",
                           G_CALLBACK (on_slave_stopped),
                           main_loop);
         gdm_slave_start (slave);
 
         g_main_loop_run (main_loop);
 
         if (slave != NULL) {
                 g_object_unref (slave);
         }
 
         if (signal_handler != NULL) {
                 g_object_unref (signal_handler);
         }
 
         g_main_loop_unref (main_loop);
 
  out:
 
         g_debug ("Slave finished");
 
         return gdm_return_code;
 }
-- 
1.9.3

